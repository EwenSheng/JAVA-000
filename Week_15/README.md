## 题目

### 第一节课

1. （必做）针对课上讲解的内容, 自己动手设计一个高并发的秒杀系统, 讲架构图,  设计文档等, 提交到 GitHub。
2. （选做）针对自己工作的系统, 或者自己思考的复杂场景, 做系统性的架构设计。

### 第二节课

1. （选做）学习《重构–改善既有代码的设计》这本书, 写读书笔记。
2. （选做）对于目前自己维护的项目代码, 思考如何改善设计和实现。

## 开发环境

```
个人终端：
处理器：AMD Ryzen 9 4900HS Radeon Graphics 3.00GHZ
RAM：40.0 GB(可用 39.4GB)
类型：x64处理器
```

```
JDK版本：
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
```

```
涉及工具：
IntelliJ IDEA 2020.2
Windows Terminal 1.3.2651.9
SuperBenchmarker 4.5.1
gateway-server-0.0.1-SNAPSHOT.jar -- 测试服务 端口8088
Google Chrome
Docker version 19.03.13
```
## 解题

### 1. 针对课上讲解的内容, 自己动手设计一个高并发的秒杀系统, 讲架构图,  设计文档等, 提交到 GitHub。


#### 总体设计

##### 组件简介

CDN:
~~~
CDN应用广泛, 支持多种行业、多种场景内容加速, 例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。
使用CDN加速域名访问
~~~

SLB: 
~~~
负载均衡SLB（Server Load Balancer）是一种对流量进行按需分发的服务, 通过将流量分发到不同的后端服务来扩展应用系统的服务吞吐能力, 并且可以消除系统中的单点故障, 提升应用系统的可用性。
使用其在第4层（传输层）的负载均衡能力
优点：
1. 面向网络交付
2. 单实例5W QPS / 基于物理机架构
~~~

OSS:
~~~
作为低成本、高可用、高扩展性的解决方案, OSS可用于存储静态HTML文件、图片、视频、JavaScript等类型的客户端脚本;
使用其存储大量商品图片
~~~

Nginx:
~~~
1. 工作在网络7层, 可以针对http应用做一些分流的策略, 比如针对域名, 目录结构
2. Nginx对网络的依赖较小, 理论上能ping通就能进行负载功能
3. Nginx安装配置比较简单, 测试起来很方便
4. 也可以承担较高的负载压力且稳定, nginx是为解决c10k问题而诞生的
5. 对后端服务器的健康检查, 只支持通过端口来检测, 不支持通过url来检测
6. Nginx对请求的异步处理可以帮助节点服务器减轻负载压力
7. Nginx仅能支持http、https和Email协议, 这样就在适用范围较小。
8. 不支持Session的直接保持, 但能通过ip_hash来解决。对Big request header的支持不是很好。
9. Nginx还能做Web服务器即Cache功能
~~~

##### 核心问题

~~~
秒杀的本质
业务上： 一场营销促销活动, 具有明确的活动业务特点
技术上： 一种主动的DDos攻击, 具备技术的不确定性和复杂度
~~~


##### 优化思路

笔记: 
1. 丢弃订单
   - 将请求尽量拦截在系统上游, 不要让锁冲突落到数据库上去, 请求如果都压倒后端数据层, 数据层读写冲突会非常严重, 并发高响应慢, 几乎所有请求都会超时, 此时流量虽大但用户下单成功率极低; ([Doge]相对来说MySQL是架构上及其脆弱的一环)
   - 可以通过前端页面定义一个值, 用户进入页面后随机一个数, 小于定义值则返回失(同理后端也可以做)
2. 优化吞吐
   - 俗称加服务器!
3. 异步队列
4. 内存分配
   - 使用Redis等缓存架构(主从,哨兵), 通过预热方式提前在每个机器的节点内存分配好库存数量,然后直接在内存里面处理库存即可;
5. 拆分扩展
   - 针对不同的业务(类型/商家/商品), 部署不同的前端集群, 把压力分散化;
6. 服务降级
   - 把次级服务(物流,订单,财务), 延后处理完, 只要保证最终是成功的; 

各层优化细节:

客户端:
~~~
1. 控制用户"下单"按钮,点击置灰; -- 前端限流
2. 通过Js限制UID每5秒提交一次请求; -- 前端限流
~~~

传输层:
~~~
1. SLB可弹性伸缩负载均衡,在这层经验不多,听运维建议是可以在这层横向扩容“优化吞吐”;
~~~

应用层:
~~~
1. 在Nginx通过Lua脚本写一个粗粒度的库存判断(T/F), 如果没有直接路由到"秒杀失败"静态页面, 减少透传到应用层的请求; -- 7层限流
2. 在Nginx同样可以实现一个基于UID每5秒提交一次请求的限制; -- 7层限流
3. 应用内可以考虑使用RateLimiter进行限流; -- 应用上层,令牌桶算法限流
4. 所有库存在活动开始时就预热到缓存(或升级为集群, Redis并发数>Mysql并发数)中, 所有对库存的操作都是通过缓存来进行, 降低Mysql压力(保证不会因为MySql宕机而导致应用雪崩问题); -- 应用上层 提升性能/优化吞吐
5. 为了提升下单的效率, 并且防止下单服务的失败。需要将下单这一操作进行异步处理,使用RocketMQ在后台经过了限流、库存校验之后, 流入到这一步骤的就是有效请求。
   然后发送到队列里,发布消息->消费消息, 异步下单->下完单->入库,随后用短信方式通知用户秒杀成功 -- 应用中层 消峰/解耦/(吞吐量小,处理时间长的业务逻辑服务)异步处理
~~~

数据库层:
~~~
1. SQL优化, 通过对表新增乐观锁(CAS 版本号)的方式, 提升性能;  -- 应用底层, 数据层
~~~

#### 系统架构图
[点击](https://github.com/EwenSheng/JAVA-000/tree/main/Week_15/static/img/second-kill-技术架构图.png)


#### 未完成,具体业务逻辑&数据库设计